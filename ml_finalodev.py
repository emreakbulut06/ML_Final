# -*- coding: utf-8 -*-
"""ML_FinalOdev.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15kgI5jqF6aVltBdWuwhfLwd-lUUGZYQV
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc

# 1. ve 2 sorular için kodlar...
# Pima Indians Diabetes Dataset'i yüklüyoruz
veri = "veri-seti.txt"
column_names = ["Pregnancies", "Glucose", "BloodPressure", "SkinThickness", "Insulin", "BMI", "DiabetesPedigreeFunction", "Age", "Outcome"]

df = pd.read_csv(veri, sep="\t", header=None, names=column_names)
df.head()

# Veri setinin genel bilgileri
df.info()

# Temel istatistikler
df.describe()

# Sınıf dağılımı
df['Outcome'].value_counts()

# Histogramlar
df.hist(bins=15, figsize=(15, 10))
plt.tight_layout()
plt.show()

# Boxplotlar
df.plot(kind='box', subplots=True, layout=(3, 3), figsize=(15, 10))
plt.tight_layout()
plt.show()

# Korelasyon matrisi
corr_matrix = df.corr()

# Heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.show()

# Eksik verileri kontrol etme
print((df[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']] == 0).sum())

# Sıfır değerleri ortalama ile doldurma
df['Glucose'] = df['Glucose'].replace(0, df['Glucose'].mean())
df['BloodPressure'] = df['BloodPressure'].replace(0, df['BloodPressure'].mean())
df['SkinThickness'] = df['SkinThickness'].replace(0, df['SkinThickness'].mean())
df['Insulin'] = df['Insulin'].replace(0, df['Insulin'].mean())
df['BMI'] = df['BMI'].replace(0, df['BMI'].mean())

# Eksik verilerin doldurulduğunu kontrol etme
print((df[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']] == 0).sum())

# Outlier'ları belirleme (z-skoru yöntemi)
from scipy import stats

z_scores = np.abs(stats.zscore(df.drop('Outcome', axis=1)))
print(np.where(z_scores > 3))  # Z-skoru 3'ten büyük olan verilerin indekslerini gösterir


# Outlier'ları belirleme (z-skoru yöntemi)
z_scores = np.abs(stats.zscore(df.drop('Outcome', axis=1)))
print(np.where(z_scores > 3))

# Outlier'ları kaldırma
df_no_outliers = df[(z_scores < 3).all(axis=1)]

# Outlier'ların kaldırıldığını kontrol etme
print(df.shape)
print(df_no_outliers.shape)

# Veriyi normalize etme
scaler = StandardScaler()
X = df_no_outliers.drop('Outcome', axis=1)
y = df_no_outliers['Outcome']
X_scaled = scaler.fit_transform(X)
#print(X_scaled)

# Veriyi eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Naive Bayes modeli eğitme
model = GaussianNB()
model.fit(X_train, y_train)

# Test seti ile tahmin yapma
y_pred = model.predict(X_test)


# Confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(conf_matrix)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix.ravel()

# Performans metriklerini hesaplama
accuracy = (TP + TN) / (TP + TN + FP + FN)
sensitivity = TP / (TP + FN)
specificity = TN / (TN + FP)
precision = TP / (TP + FP)
f1 = 2 * (precision * sensitivity) / (precision + sensitivity)

print(f"Accuracy: {accuracy:.2f}")
print(f"Sensitivity (Recall): {sensitivity:.2f}")
print(f"Specificity: {specificity:.2f}")
print(f"Precision: {precision:.2f}")
print(f"F1-Score: {f1:.2f}")

# ROC curve ve AUC
y_pred_prob = model.predict_proba(X_test)[:, 1]
fpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

#3. sorunun cevap kodları... tam süreç yazılmıştır raporda parçalarla kodlar anlatılmıstır.
from sklearn.neighbors import KNeighborsClassifier
# Veriyi yeniden eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Farklı k değerleri için KNN modelini değerlendirme
k_values = range(1, 21)
cv_scores = []

for k in k_values:
    knn = KNeighborsClassifier(n_neighbors=k)
    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring='accuracy')
    cv_scores.append(scores.mean())

# En iyi k değerini belirleme
best_k = k_values[cv_scores.index(max(cv_scores))]
print(f"En iyi k değeri: {best_k}")

# En iyi k değeri ile KNN modelini eğitme
knn = KNeighborsClassifier(n_neighbors=best_k)
knn.fit(X_train, y_train)
y_pred = knn.predict(X_test)

# Confusion matrix hesaplama
conf_matrix = confusion_matrix(y_test, y_pred)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix.ravel()

# Performans metriklerini hesaplama
accuracy = (TP + TN) / (TP + TN + FP + FN)
sensitivity = TP / (TP + FN)
specificity = TN / (TN + FP)
precision = TP / (TP + FP)
f1 = 2 * (precision * sensitivity) / (precision + sensitivity)

print(f"Accuracy: {accuracy:.2f}")
print(f"Sensitivity (Recall): {sensitivity:.2f}")
print(f"Specificity: {specificity:.2f}")
print(f"Precision: {precision:.2f}")
print(f"F1-Score: {f1:.2f}")

# ROC curve ve AUC
y_pred_prob = knn.predict_proba(X_test)[:, 1]
fpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# 4. soru için yazdığım kodlar

# Veriyi yeniden eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc


# MLP modelini eğitme
mlp = MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=1000, learning_rate_init=0.001, random_state=42, momentum=0.9)
mlp.fit(X_train, y_train)
y_pred_mlp = mlp.predict(X_test)

# Confusion matrix hesaplama
conf_matrix_mlp = confusion_matrix(y_test, y_pred_mlp)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_mlp, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('MLP Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_mlp.ravel()

# Performans metriklerini hesaplama
accuracy_mlp = (TP + TN) / (TP + TN + FP + FN)
sensitivity_mlp = TP / (TP + FN)
specificity_mlp = TN / (TN + FP)
precision_mlp = TP / (TP + FP)
f1_mlp = 2 * (precision_mlp * sensitivity_mlp) / (precision_mlp + sensitivity_mlp)

print(f"MLP Accuracy: {accuracy_mlp:.2f}")
print(f"MLP Sensitivity (Recall): {sensitivity_mlp:.2f}")
print(f"MLP Specificity: {specificity_mlp:.2f}")
print(f"MLP Precision: {precision_mlp:.2f}")
print(f"MLP F1-Score: {f1_mlp:.2f}")

# ROC curve ve AUC
y_pred_prob_mlp = mlp.predict_proba(X_test)[:, 1]
fpr_mlp, tpr_mlp, thresholds_mlp = roc_curve(y_test, y_pred_prob_mlp)
roc_auc_mlp = auc(fpr_mlp, tpr_mlp)

plt.figure(figsize=(8, 6))
plt.plot(fpr_mlp, tpr_mlp, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_mlp)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('MLP Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()


# Support Vector Machines (SVM) Modeli

# SVM modelini eğitme
svm = SVC(probability=True, random_state=42)
svm.fit(X_train, y_train)
y_pred_svm = svm.predict(X_test)

# Confusion matrix hesaplama
conf_matrix_svm = confusion_matrix(y_test, y_pred_svm)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_svm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('SVM Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_svm.ravel()

# Performans metriklerini hesaplama
accuracy_svm = (TP + TN) / (TP + TN + FP + FN)
sensitivity_svm = TP / (TP + FN)
specificity_svm = TN / (TN + FP)
precision_svm = TP / (TP + FP)
f1_svm = 2 * (precision_svm * sensitivity_svm) / (precision_svm + sensitivity_svm)

print(f"SVM Accuracy: {accuracy_svm:.2f}")
print(f"SVM Sensitivity (Recall): {sensitivity_svm:.2f}")
print(f"SVM Specificity: {specificity_svm:.2f}")
print(f"SVM Precision: {precision_svm:.2f}")
print(f"SVM F1-Score: {f1_svm:.2f}")

# ROC curve ve AUC
y_pred_prob_svm = svm.predict_proba(X_test)[:, 1]
fpr_svm, tpr_svm, thresholds_svm = roc_curve(y_test, y_pred_prob_svm)
roc_auc_svm = auc(fpr_svm, tpr_svm)

plt.figure(figsize=(8, 6))
plt.plot(fpr_svm, tpr_svm, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_svm)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('SVM Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# 5.soruda 	Size atanan veri setine tüm algoritmalar için optimizasyon uygulayınız. belirtildiği için tekrardan veri optimizasyon işlemleri uyguluyorum


"""# Veri setinin yüklenmesi
url = "veri-seti.txt"
column_names = ["Pregnancies", "Glucose", "BloodPressure", "SkinThickness", "Insulin", "BMI", "DiabetesPedigreeFunction", "Age", "Outcome"]
df = pd.read_csv(url, header=None, names=column_names)


# Eksik verileri kontrol etme
print((df[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']] == 0).sum())

# Sıfır değerleri ortalama ile doldurma
df['Glucose'].replace(0, df['Glucose'].mean(), inplace=True)
df['BloodPressure'].replace(0, df['BloodPressure'].mean(), inplace=True)
df['SkinThickness'].replace(0, df['SkinThickness'].mean(), inplace=True)
df['Insulin'].replace(0, df['Insulin'].mean(), inplace=True)
df['BMI'].replace(0, df['BMI'].mean(), inplace=True)

# Outlier'ları belirleme (z-skoru yöntemi)
z_scores = np.abs(stats.zscore(df.drop('Outcome', axis=1)))
df_no_outliers = df[(z_scores < 3).all(axis=1)]

# Veriyi normalize etme
scaler = StandardScaler()
X = df_no_outliers.drop('Outcome', axis=1)
y = df_no_outliers['Outcome']
X_scaled = scaler.fit_transform(X)"""

# 6. soru kodları
from sklearn.metrics import mean_squared_error, confusion_matrix, classification_report, roc_curve, auc
# Veriyi eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Naive Bayes modelini eğitme
nb = GaussianNB()
nb.fit(X_train, y_train)
y_pred_nb = nb.predict(X_test)

# Confusion matrix hesaplama
conf_matrix_nb = confusion_matrix(y_test, y_pred_nb)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_nb, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Naive Bayes Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_nb.ravel()

# Performans metriklerini hesaplama
accuracy_nb = (TP + TN) / (TP + TN + FP + FN)
sensitivity_nb = TP / (TP + FN)
specificity_nb = TN / (TN + FP)
precision_nb = TP / (TP + FP)
f1_nb = 2 * (precision_nb * sensitivity_nb) / (precision_nb + sensitivity_nb)

print(f"Naive Bayes Accuracy: {accuracy_nb:.2f}")
print(f"Naive Bayes Sensitivity (Recall): {sensitivity_nb:.2f}")
print(f"Naive Bayes Specificity: {specificity_nb:.2f}")
print(f"Naive Bayes Precision: {precision_nb:.2f}")
print(f"Naive Bayes F1-Score: {f1_nb:.2f}")

# ROC curve ve AUC
y_pred_prob_nb = nb.predict_proba(X_test)[:, 1]
fpr_nb, tpr_nb, thresholds_nb = roc_curve(y_test, y_pred_prob_nb)
roc_auc_nb = auc(fpr_nb, tpr_nb)

plt.figure(figsize=(8, 6))
plt.plot(fpr_nb, tpr_nb, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_nb)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Naive Bayes Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# Ortalama Karesel Hata (MSE) hesaplama
mse_nb = mean_squared_error(y_test, y_pred_nb)
print(f"Naive Bayes Mean Squared Error: {mse_nb:.2f}")

#7. sorunun cevabı kodlar

# Veriyi eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# En iyi k değerini belirlemek için cross-validation
k_range = range(1, 31)
k_scores = []

for k in k_range:
    knn = KNeighborsClassifier(n_neighbors=k)
    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring='accuracy')
    k_scores.append(scores.mean())

best_k = k_range[np.argmax(k_scores)]
print(f"En iyi k değeri: {best_k}")

# En iyi k değeri ile KNN modelini eğitme
knn = KNeighborsClassifier(n_neighbors=best_k)
knn.fit(X_train, y_train)
y_pred_knn = knn.predict(X_test)

# Confusion matrix hesaplama
conf_matrix_knn = confusion_matrix(y_test, y_pred_knn)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_knn, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('KNN Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_knn.ravel()

# Performans metriklerini hesaplama
accuracy_knn = (TP + TN) / (TP + TN + FP + FN)
sensitivity_knn = TP / (TP + FN)
specificity_knn = TN / (TN + FP)
precision_knn = TP / (TP + FP)
f1_knn = 2 * (precision_knn * sensitivity_knn) / (precision_knn + sensitivity_knn)

print(f"KNN Accuracy: {accuracy_knn:.2f}")
print(f"KNN Sensitivity (Recall): {sensitivity_knn:.2f}")
print(f"KNN Specificity: {specificity_knn:.2f}")
print(f"KNN Precision: {precision_knn:.2f}")
print(f"KNN F1-Score: {f1_knn:.2f}")

# ROC curve ve AUC
y_pred_prob_knn = knn.predict_proba(X_test)[:, 1]
fpr_knn, tpr_knn, thresholds_knn = roc_curve(y_test, y_pred_prob_knn)
roc_auc_knn = auc(fpr_knn, tpr_knn)

plt.figure(figsize=(8, 6))
plt.plot(fpr_knn, tpr_knn, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_knn)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('KNN Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# Ortalama Karesel Hata (MSE) hesaplama
mse_knn = mean_squared_error(y_test, y_pred_knn)
print(f"KNN Mean Squared Error: {mse_knn:.2f}")

#8. sorunun kodları

# Veriyi eğitim ve test setlerine bölme
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# MLP modelini eğitme
mlp = MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=900, learning_rate_init=0.002, random_state=42, momentum=0.9)
mlp.fit(X_train, y_train)
y_pred_mlp = mlp.predict(X_test)


# Confusion matrix hesaplama
conf_matrix_mlp = confusion_matrix(y_test, y_pred_mlp)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_mlp, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('MLP Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_mlp.ravel()

# Performans metriklerini hesaplama
accuracy_mlp = (TP + TN) / (TP + TN + FP + FN)
sensitivity_mlp = TP / (TP + FN)
specificity_mlp = TN / (TN + FP)
precision_mlp = TP / (TP + FP)
f1_mlp = 2 * (precision_mlp * sensitivity_mlp) / (precision_mlp + sensitivity_mlp)

print(f"MLP Accuracy: {accuracy_mlp:.2f}")
print(f"MLP Sensitivity (Recall): {sensitivity_mlp:.2f}")
print(f"MLP Specificity: {specificity_mlp:.2f}")
print(f"MLP Precision: {precision_mlp:.2f}")
print(f"MLP F1-Score: {f1_mlp:.2f}")

# ROC curve ve AUC
y_pred_prob_mlp = mlp.predict_proba(X_test)[:, 1]
fpr_mlp, tpr_mlp, thresholds_mlp = roc_curve(y_test, y_pred_prob_mlp)
roc_auc_mlp = auc(fpr_mlp, tpr_mlp)

plt.figure(figsize=(8, 6))
plt.plot(fpr_mlp, tpr_mlp, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_mlp)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('MLP Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# SVM modelini eğitme
svm = SVC(probability=True, random_state=42)
svm.fit(X_train, y_train)
y_pred_svm = svm.predict(X_test)

# Confusion matrix hesaplama
conf_matrix_svm = confusion_matrix(y_test, y_pred_svm)

# Confusion matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_svm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Non-Diabetic', 'Diabetic'],
            yticklabels=['Non-Diabetic', 'Diabetic'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('SVM Confusion Matrix')
plt.show()

# Confusion matrix bileşenlerini alma
TN, FP, FN, TP = conf_matrix_svm.ravel()

# Performans metriklerini hesaplama
accuracy_svm = (TP + TN) / (TP + TN + FP + FN)
sensitivity_svm = TP / (TP + FN)
specificity_svm = TN / (TN + FP)
precision_svm = TP / (TP + FP)
f1_svm = 2 * (precision_svm * sensitivity_svm) / (precision_svm + sensitivity_svm)

print(f"SVM Accuracy: {accuracy_svm:.2f}")
print(f"SVM Sensitivity (Recall): {sensitivity_svm:.2f}")
print(f"SVM Specificity: {specificity_svm:.2f}")
print(f"SVM Precision: {precision_svm:.2f}")
print(f"SVM F1-Score: {f1_svm:.2f}")

# ROC curve ve AUC
y_pred_prob_svm = svm.predict_proba(X_test)[:, 1]
fpr_svm, tpr_svm, thresholds_svm = roc_curve(y_test, y_pred_prob_svm)
roc_auc_svm = auc(fpr_svm, tpr_svm)

plt.figure(figsize=(8, 6))
plt.plot(fpr_svm, tpr_svm, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc_svm)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('SVM Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# Performans metriklerini bir tabloya yerleştirme
data = {
    'Model': ['MLP', 'SVM', 'KNN', 'NBayes'],
    'Accuracy': [accuracy_mlp, accuracy_svm, accuracy_knn, accuracy_nb],
    'Recall': [sensitivity_mlp, sensitivity_svm, sensitivity_knn, sensitivity_nb],
    'Specf.': [specificity_mlp, specificity_svm, specificity_knn, specificity_nb],
    'Prec.': [precision_mlp, precision_svm, precision_knn, precision_nb],
    'F1-Score': [f1_mlp, f1_svm, f1_knn, f1_nb],
    'ROC-AUC': [roc_auc_mlp, roc_auc_svm, roc_auc_knn, roc_auc_nb]
}

df_results = pd.DataFrame(data)
print(df_results)

